---
description: Best practices for mocking in tests
globs:
  - "tests/**/*.{ts,tsx}"
---

# Testing Mock Patterns

## Component Mock Props

**When to use**: Primarily for mocking framework boundaries (`next/link`, `next/image`) or third-party components. Only mock your own components when testing parent components in isolation and you have a strong reason to avoid integration-level testing.

**Problem**: Mocks ignore props that components expect, making mocks inaccurate.

**Solution**: Accept all props in mocks, even if unused. Use `eslint-disable` for intentionally unused parameters.

```tsx
// ❌ Bad - ignores props component expects
vi.mock("@ai-sdk/react", () => ({
  useChat: () => ({ messages: [] }),
}));

// ✅ Good - accepts props, marks unused as intentional
vi.mock("@ai-sdk/react", () => ({
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  useChat: ({ maxSteps }: { maxSteps?: number }) => ({ 
    messages: [],
    sendMessage: vi.fn(),
  }),
}));
```

**Note**: When mocking your own components (e.g., `Chat` when testing `ChatWidget`), ensure you have a strong reason (like avoiding API calls) and accept all props the component expects.

## Complete Module Mocks

**Problem**: Mocks don't export all symbols that components import, making mocks incomplete.

**Solution**: Export all symbols that components import from mocked modules.

```tsx
// ❌ Bad - missing DefaultChatTransport export
vi.mock("@ai-sdk/react", () => ({
  useChat: () => ({ messages: [], sendMessage: vi.fn() }),
}));

// ✅ Good - includes all imports
vi.mock("@ai-sdk/react", () => ({
  useChat: () => ({ messages: [], sendMessage: vi.fn() }),
  DefaultChatTransport: vi.fn(),
}));
```

## Test Coverage for Toggle Components

**Test both directions** of toggle functionality (open and close) for components with dual-purpose buttons.

```tsx
// ✅ Good - tests both open and close via toggle button
it("opens widget when toggle clicked", async () => {
  const user = userEvent.setup();
  render(<ChatWidget />);
  
  const toggleButton = screen.getByRole("button", { name: "Open chat" });
  expect(screen.queryByRole("dialog")).not.toBeInTheDocument();
  
  await user.click(toggleButton);
  
  expect(screen.getByRole("dialog")).toBeInTheDocument();
});

it("closes widget when toggle clicked while open", async () => {
  const user = userEvent.setup();
  render(<ChatWidget />);
  
  const toggleButton = screen.getByRole("button", { name: "Open chat" });
  
  // Open widget
  await user.click(toggleButton);
  expect(screen.getByRole("dialog")).toBeInTheDocument();
  
  // Close widget via same toggle button
  const closeButton = screen.getByRole("button", { name: "Close chat" });
  await user.click(closeButton);
  
  expect(screen.queryByRole("dialog")).not.toBeInTheDocument();
});
```
